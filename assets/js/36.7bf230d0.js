(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{806:function(t,e,a){t.exports=a.p+"assets/img/076.60c09ccd.jpg"},884:function(t,e,a){"use strict";a.r(e);var v=a(65),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"aio"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aio"}},[t._v("#")]),t._v(" AIO")]),t._v(" "),v("h2",{attrs:{id:"_1-aio编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-aio编程"}},[t._v("#")]),t._v(" 1. AIO编程")]),t._v(" "),v("ul",[v("li",[t._v("Java AIO(NIO.2)：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由 "),v("code",[t._v("OS")]),t._v(" 先完成了再通知服务器应用去启动线程进行处理")]),t._v(" "),v("li",[t._v("AIO是异步非阻塞，基于NIO，可以称之为NIO2.0")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("BIO")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("NIO")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("AIO")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("Socket")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("SocketChannel")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("AsynchronousSocketChannel")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("ServerSocket")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("ServerSocketChannel")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("AsynchronousServerSocketChannel")])])])]),t._v(" "),v("p",[t._v("与NIO不同，当进行读写操作时，只需直接调用API的 "),v("code",[t._v("read")]),t._v(" 或 "),v("code",[t._v("write")]),t._v(" 方法即可，这两种方法均为异步的，对于读操作而言，当有流可读时，操作系统会将可读的流传入read方法的缓冲区，对于写操作而言，当操作系统将 write方法传递的流写入完毕时，操作系统主动通知应用程序 。")]),t._v(" "),v("p",[t._v("可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。在 JDK1.7 中，这部分内容被称 NIO.2，主要在java.nio.channel包下增加了下面四个异步通道：")]),t._v(" "),v("ul",[v("li",[t._v("AsynchronousSocketChannel")]),t._v(" "),v("li",[t._v("AsynchronousServerSocketChannel")]),t._v(" "),v("li",[t._v("AsynchronousFileChannel")]),t._v(" "),v("li",[t._v("AsynchronousDatagramChannel")])]),t._v(" "),v("h2",{attrs:{id:"_2-总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-总结"}},[t._v("#")]),t._v(" 2. 总结")]),t._v(" "),v("h3",{attrs:{id:"_2-1-bio、nio、aio"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-bio、nio、aio"}},[t._v("#")]),t._v(" 2.1 BIO、NIO、AIO")]),t._v(" "),v("ul",[v("li",[t._v("Java BlO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动 一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善")]),t._v(" "),v("li",[t._v("Java NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理")]),t._v(" "),v("li",[t._v("Java AIO(NIO.2)：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理")])]),t._v(" "),v("br"),t._v(" "),v("img",{attrs:{height:"260px",src:a(806)}}),t._v(" "),v("br"),t._v(" "),v("h3",{attrs:{id:"_2-2-适用场景分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-适用场景分析"}},[t._v("#")]),t._v(" 2.2 适用场景分析")]),t._v(" "),v("ul",[v("li",[t._v("BlO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中， JDK1.4以前的唯一选择，但程序直观简单易理解")]),t._v(" "),v("li",[t._v("NIO方式适用于连接数目多且连接时间比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较 复杂，JDK1 .4开始支持")]),t._v(" "),v("li",[t._v("AlO方式使用于连接数目多且连接时间比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编 程比较复杂，JDK7开始支持")])]),t._v(" "),v("br")])}),[],!1,null,null,null);e.default=_.exports}}]);